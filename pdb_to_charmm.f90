   module pdb_util

!**************************************************************************************************
!a. Author - Amitava Roy                                                                          *
!b. Contact information - amitava.roy@nih.gov, amitroy74@gmail.com                                *
!c. Date - August 2nd, 2017                                                                       *
!d. Version - 1.00                                                                                *
!e. Description - The F90 code reads a PDB file, in RCSB or VMD format, and write CHARMM          *
!   formatted sequence and extended coordinate files. In the current implementation the program   *
!   allows to keep certain chains or delete certain chains. The program allows addition of a      *
!   prefix to the chain ID in the PDB file. It can check against the standard residues in         *
!   CHARMM27 parameter file and only keep them. The program writes out the atoms with missing     *
!   coordinates.  The current implementation does not read HETATM records. HIS residues in PDB    *
!   file are changed to HSD as default. It's up to the user to determine proper protonation state *
!   of individual HIStidine residues.                                                             *
!f. Detailed usage instructions -                                                                 *
!    pdb_to_charmm  xxx.pdb [xxx.cor] [xxx.seq] [keep_x] [dele_x] [prefix_xy] [preall_x]          *
!                   [standard] [nomiss] [vmd]                                                     *
!    The input can be in any order. Files are recognized by the extensions. Consequently the PDB  *
!    file has to have an extension .pdb, the sequence file has to have an extension .seq and the  *
!    coordinate files has to have extension .cor.                                                 *
!    xxx.pdb – Input PDB file name. The only required input. Maximum length of file name is 255   *
!              character.                                                                         *
!    xxx.cor – Output CHARMM formated extended coordinate file. Optional.                         *
!              Maximum length of file name is 255 character.                                      *
!    xxx.seq – Output CHARMM formated sequence file. Optional. Maximum length of file name is 255 *
!              character.                                                                         * 
!    keep_x – Keep chain id “x”. Optional. Can be repeated. Length of “x” is 1 character.  “x” is *
!             case sensitive.                                                                     *
!    dele_x – Delete chain id “x”. Optional. Can be repeated. Invalid if “keep_x” option is being *
!             used. Length of “x” is 1 character. “x” is case sensitive.                          *
!    prefix_xy – Add prefix “y” to chain id “x” . Optional. Lengths of “x” and “y” are 1          *
!                character. “x” and “y” are case sensitive.                                       *
!    preall_x – Add prefix “x” to all chain ids. Optional. Length of “x” is 1 character. “x” is   *
!               case sensitive.                                                                   *
!    standard – Keep only the residues with parameters in CHARMM27 parameter file. Optional.      *
!    nomiss – Flag to suppress atoms with missing coordinates in the REMARK section of the        *
!             coordinate file. Optional.                                                          *
!    vmd – Flag to indicate that the input PDB file has been generated by VMD. VMD uses           *
!          hexadecimal format for atom/residue numbers. Optional.                                 *
!g. Example of usage -                                                                            *
!    Compilation: ifort -mcmodel=medium -shared-intel -o pdb_to_charmm pdb_to_charmm.f90.         *
!                 pgf90 -o pdb_to_charmm pdb_to_charmm.f90                                        *
!    Change the values below in the code as needed. Higher values will require higher memory.     *
!    maxc (default=1000)- Maximum number of chain in the PDB file.                                *
!    mxca (default=600000)- Maximum number of atoms per chain. For chain containing water         *
!                           molecules this number can get big.                                    *
!    mxcr (default=350000)- Maximum number of residues per chain. For chain containing water      *
!                           molecules this number can get big.                                    *    
!   Usage: pdb_to_charmm 5iq9.pdb 5iq9_ac.seq 5iq9_ac.cor keep_A keep_C preall_P standard nomiss  *
!h. Keywords - PDB, CHARMM, FORTRAN, COORDINATE, SEQUENCE                                         *
!**************************************************************************************************

    implicit none
    integer, parameter :: maxc=1000 ! Maximum number of chain 
    integer, parameter :: mxca=600000 ! Maximum number of atoms per chain 
    integer, parameter :: mxcr=350000 ! Maximum number of residues per chain
! variables for parse_input
    integer            :: nkeep ! Number of chains to keep
    character(len=1)   :: keep(maxc) !Chain id of chains to keep
    logical            :: lkeep ! TRUE if chains are requested to be kept
    integer            :: ndele ! Number of chains to delete
    character(len=1)   :: dele(maxc) !Chain id of chains to delete
    logical            :: ldele ! TRUE if chains are requested to be deleted
    integer            :: nnam  ! Number of chains add prefix to
    character(len=1)   :: onam(maxc) ! Chain ids of chains to add prefix to
    character(len=1)   :: newn(maxc) ! prefixes to be added to the chain ids
    logical            :: lrena ! TRUE if prefix is to be added to some chians
    character(len=1)   :: pref ! Prefix to be added to all chain ids
    logical            :: prefall ! TRUE if prefix is to be added to all chain ids
    character(len=255) :: pdb ! Name of the PDB file
    character(len=255) :: seq ! Name of the sequence file
    logical            :: lseq ! TRUE if sequence output is requested
    character(len=255) :: cor ! Name of the coordinate file
    logical            :: lcor ! TRUE if coordinate output is requested
    logical            :: standard ! TRUE if only residues in c27 parameter is to be kept
    logical            :: hetatm ! TRUE if HETATM records to be read. Not implemented yet
! Variables for read_pdb 
    character(len=1)   :: cid(maxc) ! Chain IDs
    character(len=4)   :: ccid(maxc) ! CHARMM formatted Chain IDs
    integer            :: maxr(maxc) ! MAximum number of residues in a chain
    integer            :: maxa(maxc) ! MAximum number of atoms in a chain
    integer            :: misatm(maxc,mxcr) ! Number of missing atoms in a residue
    logical            :: nace(maxc) ! TRUE if Nterminal of a chain has ACE
    integer            :: nchain ! Number of chain
    character(len=4)   :: aname(maxc,mxca) ! Atom name
    character(len=3)   :: rname(maxc,mxcr) ! Residue name
    character(len=4)   :: crnam(maxc,mxcr) ! CHARMM formatted Residue name
    integer            :: resid(maxc,mxca),presid(maxc,mxca) ! Residue ID corresponding to an atom
    character(len=1)   :: insert(maxc,mxcr) ! ID for insertion
    real*4             :: x(maxc,mxca),y(maxc,mxca),z(maxc,mxca),occ(maxc,mxca),tfact(maxc,mxca)
    logical            :: cin(maxc,mxcr) ! TRUE if the residue is an insertion
    logical            :: cter(maxc),nter(maxc) ! TRUE if the chain has a CTER or NTER
    logical            :: nomiss !TRUE if missing atom information is not to be printed
    logical            :: vmd !If the PDB file was generated bi VMD
   contains
   subroutine parse_input(llseq,llcor,llrena,lprefall)
    implicit none
    logical, intent(out)   :: llseq,llcor,llrena,lprefall
    integer                :: i,j
    character(len=255)     :: arg,larg

! Parse the input
    nkeep=0
    keep=" "
    lkeep=.false.
    ndele=0
    dele=" "
    ldele=.false.
    nnam=0
    onam=" "
    newn=" "
    lrena=.false.
    pref=" "
    prefall=.false.
    pdb=" "
    seq=" "
    lseq=.false.
    cor=" "
    lcor=.false.
    hetatm=.false.
    standard=.false.
    nomiss=.false.
    vmd=.false.

    i=0
    do
     call get_command_argument(i,arg)
     if (len_trim(arg).eq.0) exit
     j=len_trim(arg)
     larg=" "
     larg(1:j)=trim(arg)
     if((larg(j-3:j).eq.'.pdb').or.(larg(j-3:j).eq.'.PDB')) then
      pdb(1:j)=larg
     endif

     if((larg(j-3:j).eq.'.cor').or.(larg(j-3:j).eq.'.COR')) then
      cor(1:j)=larg
      lcor=.true.
     endif

     if((larg(j-3:j).eq.'.seq').or.(larg(j-3:j).eq.'.SEQ')) then
      seq(1:j)=larg
      lseq=.true.
     endif

     if((larg(1:5).eq.'keep_').or.(larg(1:5).eq.'KEEP_')) then
      lkeep=.true.
      nkeep=nkeep+1
      keep(nkeep)=larg(6:6)
     endif

     if((larg(1:5).eq.'dele_').or.(larg(1:5).eq.'DELE_')) then
      ldele=.true.
      ndele=ndele+1
      dele(ndele)=larg(6:6)
     endif

     if((larg(1:7).eq.'prefix_').or.(larg(1:7).eq.'PREFIX_')) then
      lrena=.true.
      nnam=nnam+1
      onam(nnam)=larg(8:8)
      newn(nnam)=larg(9:9)
     endif

     if((larg(1:7).eq.'preall_').or.(larg(1:7).eq.'PREALL_')) then
      prefall=.true.
      pref=larg(8:8)
     endif

     if((larg(1:6).eq.'hetatm').or.(larg(1:6).eq.'HETATM')) hetatm=.true.

     if((larg(1:8).eq.'standard').or.(larg(1:8).eq.'STANDARD')) standard=.true.

     if((larg(1:6).eq.'nomiss').or.(larg(1:6).eq.'NOMISS')) nomiss=.true.

     if((larg(1:3).eq.'vmd').or.(larg(1:3).eq.'VMD')) vmd=.true.

     i=i+1
    enddo

    llseq=lseq
    llcor=lcor
    llrena=lrena
    lprefall=prefall
    return
   end subroutine parse_input 

   subroutine read_pdb(ierr)
    implicit none
    integer, intent(out) :: ierr ! 0 if reading was succesful, otherwise -1
    integer            :: chin ! Index number of chain
    integer            :: atmin ! Index number of atoms in a chain
    integer            :: resin ! Index number of residue in a chain
    integer            :: hvatm ! number of heavy atoms in a residue
    integer            :: ires ! residue number
    integer            :: presn ! Previous residue number
    logical            :: szero ! TRUE if the residue number starts from less than zero in the pdb file
    integer            :: delta ! If szero is true, add delta to start residue number form 1
    character(len=76)  :: pdblin ! each line from pdb file
    integer            :: iost ! Iostatus. If it is -1, end of file
    logical            :: readcor ! TRUE if the record starts with ATOM (or HETATM)
    character(len=6)   :: duma
    character(len=1)   :: dumb, lcid ! Chain ID
    character(len=1)   :: lcin,plcin ! current and previous Chain ID for alternate position
    character(len=4)   :: laname,vlcid ! Atom name and VMD chain ID
    character(len=3)   :: lrname,prnam ! Current and previous Residue name
    real*4             :: lx,ly,lz,locc,ltfact ! x,y,z coordinates, occpancy and B factor
    integer            :: i,j,l,m
    character(len=4)   :: dchar
    logical            :: lstay,proceed
 
! PDB file format
110 format(a6,i5,1x,a4,a1,a3,1x,a1,i4,a1,3x,3(f8.3),2(f6.2))
111 format(a6,a5,1x,a4,a1,a3,1x,a1,i4,a1,3x,3(f8.3),2(f6.2),6x,a4)

    ierr=0
    chin=0
    atmin=0
    resin=0
    hvatm=0
    presn=0
    prnam="   "
    szero=.false.
    delta=0
    maxr=0
    maxa=0
    misatm=0
    nace=.false.
    aname="    "
    rname="   "
    prnam="   "
    cid=" "
    cin=.false.
    x=0.0
    y=0.0
    z=0.0
    occ=0.0
    tfact=0.0
    cter=.false.
    nter=.false.
    if(vmd) then
     vlcid=" "
     ccid=" "
    endif

    i=len_trim(pdb)
    open(unit=11,file=pdb(1:i),status='old',err=901)
    do
     pdblin=" "
     read(11,'(a)',iostat=iost) pdblin
! Stop reading
     if(pdblin(1:4).eq.'END ') exit
     if(pdblin(1:7).eq.'ENDMDL ') exit
     if(pdblin(1:7).eq.'CONECT ') exit
     if(iost.lt.0) exit

     if(pdblin(1:4).eq.'TER ') presn=0

     readcor=.false.
     if(pdblin(1:4).eq.'ATOM') readcor=.true.
!     if(hetatm.and.(pdblin(1:6).eq.'HETATM')) readcor=.true.

     i=0
     if(readcor) then
      i=i+1
      j=len_trim(pdblin)
      if(vmd) then
       read(pdblin(1:j),111)duma,i,laname,dumb,lrname,lcid,ires,lcin,lx,ly,lz,locc,ltfact,vlcid
      else
       read(pdblin(1:j),110) duma,i,laname,dumb,lrname,lcid,ires,lcin,lx,ly,lz,locc,ltfact
      endif
!      print *, pdblin(1:j)
!Adjust for residue number starting from less than 1
      if(ires.lt.1) then
       szero=.true.
       delta=1-ires
      endif
      if(szero) ires=ires+delta

! skip the unintended chains
      lstay=.false.
      if(lkeep) then
       do l=1,nkeep
        if(lcid.eq.keep(l)) lstay=.true.
       enddo
      elseif(ldele.and.(.not.lkeep)) then
       proceed=.false.
       do l=1,ndele
        if(lcid.eq.dele(l)) proceed=.true.
       enddo
       if(.not.proceed) lstay=.true.
      elseif((.not.lkeep).and.(.not.ldele)) then
       lstay=.true.
      endif
      if(.not.lstay) cycle

! Skip for non-standard residues
      lstay=.true.
      if(standard) then
       call standard_aa(lrname,lstay)
      endif
      if(.not.lstay) presn=0
      if(.not.lstay) cycle

! Missing residue
      if((presn.ne.0).and.((ires-presn).gt.1)) presn=0

! Change of chainid
      if(chin.gt.0) then
       if(vmd) then
        if(vlcid.ne.ccid(chin)) presn=0
       else
        if(lcid.ne.cid(chin)) presn=0
       endif
      endif

! increase chain number   
      if((presn.eq.0).and.(lrname(1:3).ne."TIP")) then
       if(chin.gt.0) then
        maxa(chin)=atmin
        maxr(chin)=resin
!        if(vmd) ccid(chin)=vlcid
       endif
       chin=chin+1
       if(chin.gt.maxc) then
        print '(a48)', "Number of chain is larger than allocated memory."
        print '(a28)', "Increase MAXC and recompile."
        ierr=-1
        exit
       endif
       atmin=0
       hvatm=0
       resin=0
       szero=.false.
      endif

! increase atom number
      atmin=atmin+1
      if(atmin.gt.mxca) then
       print '(a60)', "Number of atom in a residue is larger than allocated memory."
       print '(a28)', "Increase MXCA and recompile."
       ierr=-1 
       exit
      endif

! Increase heavy atom count in the residue
      do m=1,4
       dchar=laname(m:m)
       if(dchar.ne." ") exit
      enddo
      if((dchar.eq."1").or.(dchar.eq."2").or.(dchar.eq."3").or.(dchar.eq."H")) then
       continue
      else
       hvatm=hvatm+1
      endif

! increase residue number
      if((prnam.ne.lrname).or.(presn.ne.ires).or.(lcin.ne.plcin)) then
       resin=resin+1
       if(resin.gt.mxcr) then
        print '(a61)', "Number of residue in a chain is larger than allocated memory."
        print '(a28)', "Increase MXCR and recompile."
        ierr=-1
        exit
       endif
       m=hvatom_in_res(prnam)
       if(hvatm.lt.m) then
        misatm(chin,resin-1)=m-hvatm
       elseif((hvatm.gt.m).and.(m.gt.0)) then
        misatm(chin,resin-1)=-int(hvatm/m)
       endif
       hvatm=0
! Correct for ACE N-terminal, missing atoms are ignored for ACE terminal
       if((prnam.eq.'ACE').and.(resin.eq.2)) then
        resin=1
        nace(chin)=.true.
        misatm(chin,resin)=0
       endif
       if((lrname.eq.'ACE').and.(resin.eq.2)) then
        resin=1
        lrname=rname(chin,resin)
        nace(chin)=.true.
        misatm(chin,resin)=0
       endif

       presn=ires
       plcin=lcin
       prnam=lrname
      endif

! Fill up the array to be used for coordinate and sequence file
      aname(chin,atmin)=laname
      rname(chin,resin)=lrname
      insert(chin,resin)=lcin
      resid(chin,atmin)=resin
      presid(chin,atmin)=ires
      if(vmd) then
       ccid(chin)=vlcid
      else
       cid(chin)=lcid
      endif
      if(lcin.ne." ") cin(chin,resin)=.true.
      x(chin,atmin)=lx
      y(chin,atmin)=ly
      z(chin,atmin)=lz
      occ(chin,atmin)=locc
      tfact(chin,atmin)=ltfact

     endif

! Determine if it has a CTER cap
     if(laname.eq." OXT") cter(chin)=.true.
     if(laname.eq." OT1") cter(chin)=.true.
     if(laname.eq." OT2") cter(chin)=.true.
! Determine if it has a NTER cap. Needs to improved
     if((resin.eq.1).and.(ires.le.1)) nter(chin)=.true.

    enddo
    close(unit=11)

    maxa(chin)=atmin
    maxr(chin)=resin
    nchain=chin

!   Error messages
    goto 911
901 print *, 'error in openning file, PDB file may not exist!'
    print *, trim(pdb)
911 return
   end subroutine read_pdb

   subroutine charmm_format_residue
    implicit none
    integer     :: i,j

    crnam=" "
    do i=1,nchain
     do j=1,maxr(i)
      if(rname(i,j).eq."HIS") then
       crnam(i,j)(1:3)="HSD"
      elseif((rname(i,j).eq."HOH").or.(rname(i,j).eq."TIP")) then
       crnam(i,j)(1:4)="TIP3"
      else
       crnam(i,j)(1:3)=rname(i,j)
      endif
     enddo
    enddo

    return
   end subroutine charmm_format_residue

   subroutine charmm_format_chain
    implicit none
    integer     :: i,ncid

    ccid=" "
    do i=1,nchain
     if(cid(i).eq." ") cid(i)="Z" ! Naming chain id to Z if it is blank in PDB
    enddo
    ncid=0
    do i=1,nchain
     if(maxr(i).eq.0) cycle
     ccid(i)(1:1)=cid(i)
     if((i.gt.0).and.(ccid(i)(1:1).eq.cid(i-1))) then
      ncid=ncid+1
      if(ncid.le.9) write(ccid(i)(2:2),'(i1)') ncid
      if(ncid.gt.9) write(ccid(i)(2:3),'(i2)') ncid
     else
      ncid=0
     endif
    enddo

    return
   end subroutine charmm_format_chain

   subroutine add_prefix
    implicit none
    integer     :: i,j

     if(prefall) then
      do j=1,nchain
       ccid(j)(2:4)=ccid(j)(1:3)
       ccid(j)(1:1)=pref
      enddo
     else
      do i=1,nnam
       do j=1,nchain
        if(ccid(j)(1:1).eq.onam(i)) then
         ccid(j)(2:4)=ccid(j)(1:3)
         ccid(j)(1:1)=newn(i)
       endif
       enddo
      enddo
     endif

    return
   end subroutine add_prefix

   subroutine charmm_cor
    implicit none
    integer            :: i,j,k,l,m,ncid
    character(len=4)   :: laname,cresid

! Charmm coordinate format
!100 format(i5,i5,1x,a4,1x,a4,3f10.5,1x,a4,1x,a4,f10.5)
100 format(i10,i10,2x,a4,2x,a8,4x,3f20.10,2x,a4,2x,a4,f20.10)

    j=len_trim(cor)
    open(unit=21,file=cor(1:j),status='new',err=902)
    write(21,'(a33,a)')"* Coordinate file generated from ",trim(pdb)
    do i=1,nchain
     if(.not. nomiss) then
      do j=1,maxr(i)
       if(misatm(i,j).gt.0) then
        write(21,'(a2,i2,a24,a4,a11,i4,a9,a4)')  &
         "* ",misatm(i,j)," missing atoms in chain ",ccid(i)," residue # ",j," resname ",crnam(i,j)
        print '(i2,a24,a4,a11,i4,a9,a4)',  &
         misatm(i,j)," missing atoms in chain ",ccid(i)," residue # ",j," resname ",crnam(i,j)
       endif
       if(misatm(i,j).lt.0) then
        write(21,'(a2,i2,a32,a4,a11,i4,a9,a4)')  &
         "* ",-misatm(i,j)," alternate coordinates in chain ",ccid(i)," residue # ", &
            j," resname ",crnam(i,j)
       endif
      enddo
     endif
    enddo
    write(21,'(a1)')"*"
!    write(21,'(i5)') sum(maxa(1:nchain))
    write(21,'(i10,2x,a3)') sum(maxa(1:nchain)),"EXT"
    k=0
    ncid=0
    do i=1,nchain
     if(maxr(i).eq.0) cycle
      do j=1,maxa(i)
      k=k+1
      m=resid(i,j)
      l=sum(maxr(1:i-1))+m

      cresid=" "
      if((presid(i,j).gt.999)) then
       write(cresid,'(i4)') presid(i,j)
      elseif(presid(i,j).le.9) then
       write(cresid(1:1),'(i1)') presid(i,j)
       cresid(2:2)=insert(i,m)
      elseif((presid(i,j).gt.9).and.(presid(i,j).le.99)) then
       write(cresid(1:2),'(i2)') presid(i,j)
       cresid(3:3)=insert(i,m)
      elseif((presid(i,j).gt.99).and.(presid(i,j).le.999)) then
       write(cresid(1:3),'(i3)') presid(i,j)
       cresid(4:4)=insert(i,m)
      endif

      laname=" "
      if(aname(i,j)(1:1).eq." ") then
       if((aname(i,j)(2:4).eq."CD1").and.(rname(i,m).eq."ILE")) then
        laname(1:2)="CD"
       elseif((cter(i)).and.(m.eq.maxr(i)).and.(aname(i,j)(2:4).eq."O  ")) then
        laname(1:3)="OT2"
       elseif((cter(i)).and.(m.eq.maxr(i)).and.(aname(i,j)(2:4).eq."OXT")) then
        laname(1:3)="OT1"
       else
        laname(1:3)=aname(i,j)(2:4)
       endif
      elseif((aname(i,j)(1:1).eq."1").or.(aname(i,j)(1:1).eq."1").or.(aname(i,j)(1:1).eq."1")) then
       laname(1:3)=aname(i,j)(2:4)
       laname(4:4)=aname(i,j)(1:1)
      elseif((aname(i,j)(1:1).eq."2").or.(aname(i,j)(1:1).eq."2").or.(aname(i,j)(1:1).eq."2")) then
       laname(1:3)=aname(i,j)(2:4)
       laname(4:4)=aname(i,j)(1:1)
      elseif((aname(i,j)(1:1).eq."3").or.(aname(i,j)(1:1).eq."3").or.(aname(i,j)(1:1).eq."3")) then
       laname(1:3)=aname(i,j)(2:4)
       laname(4:4)=aname(i,j)(1:1)
      else
       laname=aname(i,j)
      endif

! Rewrite ACE terminal atom names to match with CHARMM format
      if(nace(i).and.(m.eq.1)) then
       if(aname(i,j).eq." CH3") laname="CAY "
       if(aname(i,j).eq." C  ") laname="CY  "
       if(aname(i,j).eq." O  ") laname="OY  "
       if(aname(i,j).eq."HH31") laname="HY1 "
       if(aname(i,j).eq."HH32") laname="HY2 "
       if(aname(i,j).eq."HH33") laname="HY3 "
      endif

      write(21,100) k,l,crnam(i,m),laname,x(i,j),y(i,j),z(i,j),ccid(i),cresid,tfact(i,j)
     enddo
    enddo
    close(unit=21)
!   Error messages
    goto 912
902 print *, 'error in openning file, Corodinate file may already exist!'
    print *, trim(cor)
912 return
   end subroutine charmm_cor

   subroutine charmm_seq
    implicit none
    integer          :: i,j,k,ncid
    character(len=4) :: ccap,ncap

    j=len_trim(seq)
    open(unit=22,file=seq(1:j),status='new',err=903)
    write(22,'(a31,a)')"* Sequence file generated from ",trim(pdb)
    write(22,'(a65)')"* If residue number in N-terminal is <= 1 in PDB, NTER is assumed"
    write(22,'(a61)')"* If OXT is present in the c-terminal in PDB, CTER is assumed"
    write(22,'(a70)')"* Segments are splitted if missing residue is in the middle of a chain"
    write(22,'(a61)')"* SEGID of such segments has a number after the PDB chain ID."
    write(22,'(a54)')"* Also segment with only one residue has been ignored."
    write(22,'(a1)')"*"
    ncid=0

    do i=1,nchain
     if(maxr(i).eq.0) cycle
     write(22,'(a)')
     write(22,'(a14)')"READ SEQU CARD"
     write(22,'(a31,a)') "* Sequence file generated from ",trim(pdb)
     write(22,'(a1)')"*"
     write(22,'(i5)') maxr(i)
     do j=1,int(maxr(i)/10)
      write(22,'(10(1x,a3,1x))') (crnam(i,(j-1)*10+k),k=1,10)
     enddo
     write(22,'(10(1x,a3,1x))') (crnam(i,k),k=(j-1)*10+1,maxr(i))
     if(cter(i)) then
      ccap='CTER'
     else
      ccap='NONE'
     endif
     if(nace(i)) then
      ncap='ACE '
     else
      if(nter(i)) then
       if(crnam(i,1).eq.'GLY ') then
        ncap='GLYP'
       elseif(crnam(i,1).eq.'PRO ') then
        ncap='PROP'
       else
        ncap='NTER'
       endif
      else
       ncap='NONE'
      endif
     endif
     write(22,'(a5,a4,a7,a4,a6,a4,a5)') "GENE ",ccid(i)," FIRST ",ncap," LAST ",ccap," SETU"
    enddo
    close (unit=22)

!   Error messages
    goto 913
903 print *, 'error in openning file, Sequence file may already exist!'
    print *, trim(seq)
913 return
   end subroutine charmm_seq

   subroutine standard_aa(aa,std)
    implicit none
    character(len=3)    :: aa
    logical             :: std

    std=.false.
    if(aa.eq.'ALA') std=.true.
    if(aa.eq.'ARG') std=.true.
    if(aa.eq.'ASN') std=.true.
    if(aa.eq.'ASP') std=.true.
    if(aa.eq.'CYS') std=.true.
    if(aa.eq.'GLN') std=.true.
    if(aa.eq.'GLU') std=.true.
    if(aa.eq.'GLY') std=.true.
    if(aa.eq.'HIS') std=.true.
    if(aa.eq.'HSD') std=.true.
    if(aa.eq.'HSP') std=.true.
    if(aa.eq.'HSE') std=.true.
    if(aa.eq.'ILE') std=.true.
    if(aa.eq.'LEU') std=.true.
    if(aa.eq.'LYS') std=.true.
    if(aa.eq.'MET') std=.true.
    if(aa.eq.'PHE') std=.true.
    if(aa.eq.'PRO') std=.true.
    if(aa.eq.'SER') std=.true.
    if(aa.eq.'THR') std=.true.
    if(aa.eq.'TRP') std=.true.
    if(aa.eq.'TYR') std=.true.
    if(aa.eq.'VAL') std=.true.
    if(aa.eq.'HOH') std=.true.
    if(aa.eq.'SOD') std=.true.
    if(aa.eq.'CAL') std=.true.
    if(aa.eq.'CLA') std=.true.
    if(aa.eq.'MG ') std=.true.
    if(aa.eq.'POT') std=.true.
    if(aa.eq.'CES') std=.true.
    if(aa.eq.'ZN2') std=.true.
    if(aa.eq.'ZN ') std=.true.
    if(aa.eq.'GUA') std=.true.
    if(aa.eq.'ADE') std=.true.
    if(aa.eq.'CYT') std=.true.
    if(aa.eq.'THY') std=.true.
    if(aa.eq.'URA') std=.true.

    if(.not.std) print '(a20,1x,a3)', "Non standard residue",aa
    return
    end subroutine standard_aa

   function hvatom_in_res(aa) result(natm)
    implicit none
    character(len=3), intent(in) :: aa ! input
    integer                      :: natm ! output

    if(aa.eq.'ALA') natm=5
    if(aa.eq.'ARG') natm=11
    if(aa.eq.'ASN') natm=8
    if(aa.eq.'ASP') natm=8
    if(aa.eq.'CYS') natm=6
    if(aa.eq.'GLN') natm=9
    if(aa.eq.'GLU') natm=9
    if(aa.eq.'GLY') natm=4
    if(aa.eq.'HIS') natm=10
    if(aa.eq.'HSD') natm=10
    if(aa.eq.'HSP') natm=10
    if(aa.eq.'HSE') natm=10
    if(aa.eq.'ILE') natm=8
    if(aa.eq.'LEU') natm=8
    if(aa.eq.'LYS') natm=9
    if(aa.eq.'MET') natm=8
    if(aa.eq.'PHE') natm=11
    if(aa.eq.'PRO') natm=7
    if(aa.eq.'SER') natm=6
    if(aa.eq.'THR') natm=7
    if(aa.eq.'TRP') natm=14
    if(aa.eq.'TYR') natm=12
    if(aa.eq.'VAL') natm=7
    if(aa.eq.'HOH') natm=1
    if(aa.eq.'SOD') natm=1
    if(aa.eq.'CAL') natm=1
    if(aa.eq.'CLA') natm=1
    if(aa.eq.'MG ') natm=1
    if(aa.eq.'POT') natm=1
    if(aa.eq.'CES') natm=1
    if(aa.eq.'ZN2') natm=1
    if(aa.eq.'ZN ') natm=1
    if(aa.eq.'GUA') natm=22
    if(aa.eq.'ADE') natm=22
    if(aa.eq.'CYT') natm=20
    if(aa.eq.'THY') natm=22
    if(aa.eq.'URA') natm=20
   end function hvatom_in_res

   end module pdb_util

   program pdb_to_charmm
    use pdb_util
    implicit none
    logical          :: llseq,llcor,llrena,lprefall
    integer          :: ierr
    call parse_input(llseq,llcor,llrena,lprefall)
    call read_pdb(ierr)
    if(ierr.ge.0) then
     call charmm_format_residue
     if(.not. vmd) call charmm_format_chain
     if(llrena.or.lprefall) call add_prefix
     if(llcor) call charmm_cor
     if(llseq) call charmm_seq
    endif
   end program pdb_to_charmm
 
